/*
Copyright 2015 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Package args has common command-line flags for generation programs.
package args

import (
	"bytes"
	goflag "flag"
	"fmt"
	"io/ioutil"
	"os"
	"path"
	"strconv"
	"strings"
	"time"

	"k8s.io/gengo/v2/generator"
	"k8s.io/gengo/v2/namer"
	"k8s.io/gengo/v2/parser"

	"github.com/spf13/pflag"
)

// Default returns a defaulted GeneratorArgs. You may change the defaults
// before calling AddFlagsTo.
func Default() *GeneratorArgs {
	return &GeneratorArgs{
		OutputBase:                 ".",
		GeneratedBuildTag:          "ignore_autogenerated",
		GeneratedByCommentTemplate: "// Code generated by GENERATOR_NAME. DO NOT EDIT.",
	}
}

// GeneratorArgs has arguments that are passed to generators.
type GeneratorArgs struct {
	// Which directories to parse.
	InputDirs []string

	// Source tree to write results to.
	OutputBase string

	// Package path within the source tree.
	OutputPackagePath string

	// Output file name.
	OutputFileBaseName string

	// Where to get copyright header text.
	GoHeaderFilePath string

	// If GeneratedByCommentTemplate is set, generate a "Code generated by" comment
	// below the bloilerplate, of the format defined by this string.
	// Any instances of "GENERATOR_NAME" will be replaced with the name of the code generator.
	GeneratedByCommentTemplate string

	// If true, only verify, don't write anything.
	VerifyOnly bool

	// If true, include *_test.go files
	IncludeTestFiles bool

	// GeneratedBuildTag is the tag used to identify code generated by execution
	// of this type. Each generator should use a different tag, and different
	// groups of generators (external API that depends on Kube generations) should
	// keep tags distinct as well.
	GeneratedBuildTag string

	// Any custom arguments can go here.
	CustomArgs CustomArgs

	// Any custom arg validation can go here.
	Validate func(args *GeneratorArgs) error

	// If specified, trim the prefix from OutputPackagePath before writing files.
	//FIXME: remove this?  Clean up "OutputBase" etc to make sense.  Maybe "alt-gopath-root" ?
	TrimPathPrefix string
}

type CustomArgs interface {
	AddFlagsTo(fs *pflag.FlagSet)
}

// Simpler:
//
//	inputs are real arguments, not flags, can be pkgs or dirs
//	--output-dir is a semi-custom (genericArgs.EnableOutputDir())
//	otherwise input is assumed to be decided by the tool, usually same as input
//	  maybe that is a tool.Get OutDir() method
//	drop output-package?  or treat it the same way
func (g *GeneratorArgs) AddFlagsTo(fs *pflag.FlagSet) {
	fs.StringSliceVarP(&g.InputDirs, "input-dirs", "i", g.InputDirs, "Comma-separated list of import paths to get input types from.")
	fs.StringVarP(&g.OutputBase, "output-base", "o", g.OutputBase, "Output base; defaults to current dir.")
	fs.StringVarP(&g.OutputPackagePath, "output-package", "p", g.OutputPackagePath, "Base package path.")
	fs.StringVarP(&g.OutputFileBaseName, "output-file-base", "O", g.OutputFileBaseName, "Base name (without .go suffix) for output files.")
	fs.StringVarP(&g.GoHeaderFilePath, "go-header-file", "h", g.GoHeaderFilePath, "File containing boilerplate header text. The string YEAR will be replaced with the current 4-digit year.")
	fs.BoolVar(&g.VerifyOnly, "verify-only", g.VerifyOnly, "If true, only verify existing output, do not write anything.")
	fs.StringVar(&g.GeneratedBuildTag, "build-tag", g.GeneratedBuildTag, "A Go build tag to use to identify files generated by this command. Should be unique.")
	fs.StringVar(&g.TrimPathPrefix, "trim-path-prefix", g.TrimPathPrefix, "If set, trim the specified prefix from --output-package when generating files.")
}

// GoBoilerplate loads the boilerplate file passed to --go-header-file.
func (g *GeneratorArgs) GoBoilerplate() ([]byte, error) {
	buf := bytes.Buffer{}

	if g.GeneratedBuildTag != "" {
		s := fmt.Sprintf("//go:build !%s\n// +build !%s\n\n", g.GeneratedBuildTag, g.GeneratedBuildTag)
		buf.WriteString(s)
	}

	if g.GoHeaderFilePath != "" {
		b, err := ioutil.ReadFile(g.GoHeaderFilePath)
		if err != nil {
			return nil, err
		}
		b = bytes.Replace(b, []byte("YEAR"), []byte(strconv.Itoa(time.Now().UTC().Year())), -1)
		buf.Write(b)
		buf.WriteByte('\n')
	}

	if g.GeneratedByCommentTemplate != "" {
		generatorName := path.Base(os.Args[0])
		generatedByComment := strings.Replace(g.GeneratedByCommentTemplate, "GENERATOR_NAME", generatorName, -1)
		s := fmt.Sprintf("%s\n\n", generatedByComment)
		buf.WriteString(s)
	}

	return buf.Bytes(), nil
}

// NewBuilder makes a new parser.Builder and populates it with the input
// directories.
func (g *GeneratorArgs) NewBuilder() (*parser.Builder, error) {
	b := parser.New(g.IncludeTestFiles, g.GeneratedBuildTag)

	if err := b.AddDirs(g.InputDirs); err != nil {
		return nil, err
	}
	return b, nil
}

// Execute implements main().
// If you don't need any non-default behavior, use as:
// args.Default().Execute(...)
func (g *GeneratorArgs) Execute(nameSystems map[string]namer.Namer, defaultSystem string, pkgs func(*generator.Context, *GeneratorArgs) []generator.Package) error {
	g.AddFlagsTo(pflag.CommandLine)
	if g.CustomArgs != nil {
		g.CustomArgs.AddFlagsTo(pflag.CommandLine)
	}
	pflag.CommandLine.AddGoFlagSet(goflag.CommandLine)
	pflag.Parse()
	if g.Validate != nil {
		if err := g.Validate(g); err != nil {
			return err
		}
	}

	b, err := g.NewBuilder()
	if err != nil {
		return fmt.Errorf("Failed making a parser: %v", err)
	}

	c, err := generator.NewContext(b, nameSystems, defaultSystem)
	if err != nil {
		return fmt.Errorf("Failed making a context: %v", err)
	}

	c.TrimPathPrefix = g.TrimPathPrefix
	c.Verify = g.VerifyOnly

	packages := pkgs(c, g)
	if err := c.ExecutePackages(g.OutputBase, packages); err != nil {
		return fmt.Errorf("Failed executing generator: %v", err)
	}

	return nil
}
