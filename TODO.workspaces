Move FormatOnly to gengo
  - results in importing "self pkg" in each file
Move namer/import tweaks to prefactoring and see if dbsmith hates them
client-go and other codegens - use zz_generated.* names?


rebase frequently
  - update gengo
  - update kube-openapi
Don't put gengo2 and kube-openapi-hack in go.work
Step thru commits and run `go work sync`
  - maybe add that to the verify-go-workspace script?
Decide and document: how to install tools
Decide: vendor vs checked-in modcache vs nothing
find all GOPATH and gopath and _gopath
find all `go build` and `go install`
find all "vendor/..."
find all GO111MODULE
all test stuff
decide: go caches (GOCACHE and GOMODCACHE) in _output or no?
partial codegens should exit tools with failure
fix all gengo/v2 FIXMEs and minimize
Try to make all codegens work at each step?
Protobuf and others should be in update-codegen
find and remove all ./output and _gopath refs (weird old names?)
Do we commit go.work.sum?  How do I force it to generate?
  - Why is it different at the end of my stack - where did it change?
gengo/v2:
  - strategy:
    - convert all tools to v2
    - convert all to get rid of OutputBase
    - for each tool (ALL OF THEM)
      - make necessary v2 changes
    - delete the rest of gengo/v2
    - rename and move
  - universe holds funcs and packages?
  - findTypes puts .types[] on funcs
  - universe[pkg].SourcePath is not populated
  - setting package.Source is a hack - generators should not need to set it
    - we can look it up in universe (have to Load it first) but what if it
      doesn't exit?  Maybe we don't care, or just use outputBase
  - "genericArgs.Execute" -> "gengo.Execute"
  - packages.Load already finds types and funcs
  - don't set flags internally - use the scripts
  - rationalize what is a dir and what is a pkg
  - use types for pkg names vs local vs string
kill off find-binary shell function
remove defaulter --extra-peer-dirs flag
remove conversion --extra-dirs flag
hack/
    benchmark-go.sh
    boilerplate
    build-cross.sh
    build-go.sh
    cherry_pick_pull.sh
    conformance
    dev-build-and-push.sh
    dev-build-and-up.sh
    dev-push-conformance.sh
    e2e-internal
    e2e-node-test.sh
    generate-docs.sh
    gen-swagger-doc
    get-build.sh
    ginkgo-e2e.sh
    grab-profiles.sh
    install-etcd.sh
    jenkins
    lib
    lint-dependencies.sh
    list-feature-tests.sh
    local-up-cluster.sh
    logcheck.conf
    make-rules
    module-graph.sh
    OWNERS
    pin-dependency.sh
    print-workspace-status.sh
    README.md
    run-prometheus-on-etcd-scrapes.sh
    serve-prom-scrapes.sh
    testdata
    test-go.sh
    test-integration.sh
    tools
    unwanted-dependencies.json
    update-all.sh
    update-codegen.sh
    update-conformance-yaml.sh
    update-generated-api-compatibility-data.sh
    update-generated-device-plugin-dockerized.sh
    update-generated-device-plugin.sh
    update-generated-docs.sh
    update-generated-kms-dockerized.sh
    update-generated-kms.sh
    update-generated-kubelet-plugin-registration-dockerized.sh
    update-generated-kubelet-plugin-registration.sh
    update-generated-pod-resources-dockerized.sh
    update-generated-pod-resources.sh
    update-generated-protobuf-dockerized.sh
    update-generated-protobuf.sh
    update-generated-runtime-dockerized.sh
    update-generated-runtime.sh
    update-generated-stable-metrics.sh
    update-generated-swagger-docs.sh
    update-gofmt.sh
    update-import-aliases.sh
    update-internal-modules.sh
    update-kustomize.sh
    update-netparse-cve.sh
    update-openapi-spec.sh
    update-translations.sh
    update-vendor-licenses.sh
    update-vendor.sh
    verify-codegen.sh
    verify-conformance-requirements.sh
    verify-conformance-yaml.sh
    verify-description.sh
    verify-e2e-test-ownership.sh
    verify-external-dependencies-version.sh
    verify-flags
    verify-flags-underscore.py
    verify-generated-device-plugin.sh
    verify-generated-docs.sh
    verify-generated-kms.sh
    verify-generated-kubelet-plugin-registration.sh
    verify-generated-pod-resources.sh
    verify-generated-protobuf.sh
    verify-generated-runtime.sh
    verify-generated-stable-metrics.sh
    verify-generated-swagger-docs.sh
    verify-gofmt.sh
    verify-golangci-lint.sh
    verify-govet-levee.sh
    verify-govet.sh
    verify-import-aliases.sh
    verify-import-boss.sh
    verify-imports.sh
    verify-internal-modules.sh
    verify-licenses.sh
    verify-linkcheck.sh
    verify-netparse-cve.sh
    verify-non-mutating-validation.sh
    verify-openapi-spec.sh
    verify-pkg-names.sh
    verify-prerelease-lifecycle-tags.sh
    verify-prometheus-imports.sh
    verify-publishing-bot.py
    verify-readonly-packages.sh

    verify-vendor-licenses.sh
    verify-vendor.sh
    verify-no-vendor-cycles.sh

Why do we have staging/src/k8s.io/code-generator/hack/boilerplate.go.txt and
  hack/boilerplate/... and in staging/src/k8s.io/code-generator/hack and ...

Drop --logtostderr in makefile calls to generators - default?

All the scripts called by hack/update-codegen.sh are awful
  * Do they get all the flags right?

kill staging/src/k8s.io/code-generator/pkg/util

gengo2/v2/types/types.go::Package.Type adds all pointers, func, method, etc to pkg ""
  - is that right?

Why do we Order by a Namer?  Why does that matter?
  - rename Order to Index ?

Boilerplate is very Go centric - doesn't need to be
  - take multiple header args, like go:path, proto:path.  Make default be "go:"
  - should be per file

Rename Generator -> File or something?

gengo tools:
---------------
./staging/src/k8s.io/code-generator/cmd/prerelease-lifecycle-gen \
  --v 1 \
  --logtostderr \
  -h staging/src/k8s.io/code-generator/hack/boilerplate.go.txt \
  --output-file-base zz_generated.prerelease-lifecycle \
  --input-dirs ./staging/src/k8s.io/api/admission/v1beta1

main
	local argspkg NewDefaults()
		gengo args.Default().WithoutDefaultFlagParsing()
		no custom args
		set OutputFileBaseName # TODO: don't
	set logtostderr # TODO: don't set it from script
	parse flags
	local argspkg Validate()
		verify OutputFileBaseName != ""
	namers:
		"public": namer.NewPublicNamer(1)
		"raw":    namer.NewRawNamer("", nil)
	default namer = "public"
	gengo args.GeneratorArgs.Execute()
		check default flags (which is false as per above) # TODO: does anyone use this path?
		b = g.NewBuilder()
			parser.New(testfiles = false, tag = "ignore_autogenerated"
				retun new parser.Builder
			b.AddDirs(inputs)
				b.loadDirs(inputs)
						for each dir
						convert to importPathString
						decide if net-new or already known
					packages.Load(net new dirs)
					for each pkg
						b.processPkg(p, userRequested = true)
							convert pkg.ID to importPathString
							#TODO: types to denote "ppossibley local" vs "canonical"
							save in b.pkgmap
							set b.userRequested
							if errors are packages.ListError
								print and exit
				} end loadDirs
			} end AddDirs
		} end NewBuilder
		c = gengo generator.NewContext()
			universe = b.FindTypes
				sort all pkgPaths in b.pkgMap
				u = new Universe
				for each pkg
					convert to importPathString
					b.findTypesIn(p) -> universe
						global typesFound[] # TODO: should be in b
						if !user requested
							return
						if no go files
							# TODO: should this consider IgnoredFiles too?
							return
						get abs path
						u.Package(string(pkgpath) => types.Package
							if found, return it
							else add it
						set Name (short, self-determined)
						set Path = canon ID
						set SourcePath = abs
						for each syntax item
							if doc.go
								collect comments, split by line
								# TODO: break loop?
						s = Scope() (std type)
						for each name in scope
							if name is a type name
								b.walkType()
									u.Type(name)
									b.addCommentsToType
							if name is a func name
								??????
							if name is a var and not a field
								b.addVariable()
									u.Package().Variable()
									set Kind = types.DeclarationOf
									set Underlying = walkType()
										u.Type(name)
										set Kind = types.Func
								b.addCommentsToType
									accumulate comments and SecondClosestCommentLines
							if name is a const name
								??????
					} end find types in
			} end FindTypes
			inp = b.FindPackages
				collect and sort all pkgs
				for each pkg
					if user-requested, keep it
			c = gengo generator.Context
				Names = empty
				Univers = u
				Inputs = inp
				builder = b
			c.Names = clone input namesystems
			c.Order = namer.Orderer.OrderUniverse(u)
				sort all types in universe
		} end NewContext
		set c.TrimPathPrefix
		set c.Verify
		call local callback -> Packages(generator.Context, args) => generator.Packages
			gengo LoadGoBoilerplate() (reads g.GoHeaderFilePath)
			header = manually compsed "+build" ... + arguments.GeneratedBuildTag + boilerplate
			for each input string
				get pkg, not nil
				look for tag "k8s:prerelease-lifecycle-gen"
				append generator.DefaultPackage {
					PackageName = basename of pkg.Path
					PackagePath =  path (same?)
					Source = abs path
					GeneratorFunc = ...NewPrereleaseLifecycleGen
		} end of Packages()
		c.ExecutePackages(g.OutputBase, pkgs)
			for each pkg
				c.ExecutePackage(g.OutputBase, pkg)
					path = p.SourcePath
					pkgctxt = c.filteredBy(p.Filter)
						copy context
						call filter on each type, keep matches
					mkdir -p path #TODO: this is the source path not output
					gens = call pkg.Generators(pkgctxt)
						return &genPreleaseLifecycle {
							targetPackage = path
							imports = generator.NewImportTracker(),
								namer.NewDefaultImportTracker(types.Name{})
					for each gen in gens
						genctxt = c.filteredBy(g.Filter) 
							if not API type, ignore
						genctxt.addNameSystems(generator namers)
						add file g.Filename to map
						call g.PackageVars(genContext)
						for each var {
							printf to buffer
						for each const {
							printf to buffer
						genContext.executeBody
							for each type in c.Order
								generator.GenerateType
							generator.Finalize
						g.Imports
							# TODO: g.isOtherPackage strcmps against `foo "pkg.com/foo"`
						save f.Imports as a map of `foo "pkg.com/foo"` -> nothing
					for each file
						assemble final path from path + f.Name
				} end ExecutePackage
		} end ExecutePackages

./staging/src/k8s.io/code-generator/cmd/deepcopy-gen \
  --v 1 \
  --logtostderr \
  --go-header-file staging/src/k8s.io/code-generator/hack/boilerplate.go.txt \
  --output-file-base zz_generated.deepcopy \
  --bounding-dirs k8s.io/kubernetes,k8s.io/api \
  --input-dirs ./pkg/apis/networking


	local argspkg NewDefaults()
		gengo args.Default().WithoutDefaultFlagParsing()
		1 custom arg
		set OutputFileBaseName # TODO: don't
	set logtostderr # TODO: don't set it from script
	parse flags
	local argspkg Validate()
		verify OutputFileBaseName != ""
	namers:
		"public": deepCopyNamer() # TODO: use PublicName (TODO in code)
		"raw":    namer.NewRawNamer("", nil)
	default namer = "public"
	gengo args.GeneratorArgs.Execute()
		check default flags (which is false as per above) # TODO: does anyone use this path?
		b = g.NewBuilder()
			parser.New(testfiles = false, tag = "ignore_autogenerated"
				retun new parser.Builder
			b.AddDirs(inputs)
				SAME AS ABOVE
		} end NewBuilder
		c = gengo generator.NewContext()
			SAME AS ABOVE
		set c.TrimPathPrefix
		set c.Verify
		call local callback -> Packages(generator.Context, args) => generator.Packages
			gengo LoadGoBoilerplate() (reads g.GoHeaderFilePath)
			header = manually compsed "+build" ... + arguments.GeneratedBuildTag + boilerplate
			parse custom arg (bounding dirs) #TODO: do we still need it?
			for each input string
				get pkg, not nil
				look for tag
				parse tag args
				append generator.DefaultPackage {
					PackageName = basename of pkg.Path
					PackagePath =  path (same?)
					Source = abs path
					GeneratorFunc = ...NewGenDeepCopy
		} end of Packages()
		c.ExecutePackages(g.OutputBase, pkgs)
			for each pkg
				c.ExecutePackage(g.OutputBase, pkg)
					path = p.SourcePath
					pkgctxt = c.filteredBy(p.Filter)
						copy context
						call filter on each type, keep matches
					mkdir -p path #TODO: this is the source path not output
					gens = call pkg.Generators(pkgctxt)
						return &genDeepCopy {
							targetPackage = path
							imports = generator.NewImportTracker(),
								namer.NewDefaultImportTracker(types.Name{})
					for each gen in gens
						genctxt = c.filteredBy(g.Filter) 
							if not enabled or not copyable, skip
						genctxt.addNameSystems(generator namers)
							"raw" tracks imports with "this pkg" context
						add file g.Filename to map
						call g.PackageVars(genContext)
						for each var {
							printf to buffer
						for each const {
							printf to buffer
						genContext.executeBody
							for each type in c.Order
								generator.GenerateType
							generator.Finalize
						g.Imports
							# TODO: g.isOtherPackage strcmps against `foo "pkg.com/foo"`
						save f.Imports as a map of `foo "pkg.com/foo"` -> nothing
					for each file
						assemble final path from path + f.Name
				} end ExecutePackage
		} end ExecutePackages




./staging/src/k8s.io/code-generator/cmd/defaulter-gen \
  --v 1 \
  --logtostderr \
  -h staging/src/k8s.io/code-generator/hack/boilerplate.go.txt \
  -O zz_generated.defaults \
  -i ./pkg/scheduler/apis/config/v1beta3

main
	local argspkg NewDefaults()
		gengo args.Default().WithoutDefaultFlagParsing()
		1 custom arg (ExtraPeerDirs)
		set OutputFileBaseName # TODO: don't
	set logtostderr # TODO: don't set it from script
	parse flags
	local argspkg Validate()
		verify OutputFileBaseName != ""
	namers:
		"public": namer.NewPublicNamer(1)
		"raw":    namer.NewRawNamer("", nil)
		"defaultfn":       defaultFnNamer(),
		"objectdefaultfn": objectDefaultFnNamer(),
	default namer = "public"
	gengo args.GeneratorArgs.Execute()
		check default flags (which is false as per above) # TODO: does anyone use this path?
		b = g.NewBuilder()
			SAME AS ABOVE
		c = gengo generator.NewContext()
			SAME AS ABOVE
		set c.TrimPathPrefix
		set c.Verify
		call local callback -> Packages(generator.Context, args) => generator.Packages
			gengo LoadGoBoilerplate() (reads g.GoHeaderFilePath)
			header = manually compsed "+build" ... + arguments.GeneratedBuildTag + boilerplate
			for each input string
				get pkg, not nil
				look for tag 
				Accumulate "other" inputs
					# TODO: weird rules about relative paths don't apply any more?
				context.AddDirs()
					ctxt.builder.AddDirsTo(ctxt.Universe)
						b.loadDirs()
							packages.Load()
						for each pkg
							b.findTypesIn(pkgPath, u)
				Update context Order # TODO: should be in AddDirsTo?
				for each extra peer dir
					context.AddDir()
						# TODO: unused
				Emit for each defaulter # TODO: why here?
				context.AddDirectory # TODO: as a lookup?
				append generator.DefaultPackage {
					PackageName = basename of pkg.Path
					PackagePath =  path (same?)
					Source = abs path
					GeneratorFunc = ...NewGenDefaulter
		} end of Packages()
		c.ExecutePackages(g.OutputBase, pkgs)
			for each pkg
				c.ExecutePackage(g.OutputBase, pkg)
					path = p.SourcePath
					pkgctxt = c.filteredBy(p.Filter)
						copy context
						call filter on each type, keep matches
					mkdir -p path #TODO: this is the source path not output
					gens = call pkg.Generators(pkgctxt)
						return &DefaultGen {
							targetPackage = path
							imports = generator.NewImportTracker(),
								namer.NewDefaultImportTracker(types.Name{})
					for each gen in gens
						genctxt = c.filteredBy(g.Filter) 
						genctxt.addNameSystems(generator namers)
						add file g.Filename to map
						call g.PackageVars(genContext)
						for each var {
							printf to buffer
						for each const {
							printf to buffer
						genContext.executeBody
							Init
								for each defaulter
									add register call
							for each type in Order
								emit
							generator.Finalize
						g.Imports
							# TODO: g.isOtherPackage strcmps against `foo "pkg.com/foo"`
						save f.Imports as a map of `foo "pkg.com/foo"` -> nothing
					for each file
						assemble final path from path + f.Name
				} end ExecutePackage
		} end ExecutePackages


k8s.io/code-generator/cmd/conversion-gen \
  -h staging/src/k8s.io/code-generator/hack/boilerplate.go.txt \
  -O zz_generated.conversion \
  --extra-peer-dirs k8s.io/kubernetes/pkg/apis/core \
  --extra-peer-dirs k8s.io/kubernetes/pkg/apis/core/v1 \
  --extra-peer-dirs k8s.io/api/core/v1 \
  -i ./pkg/apis/networking/v1beta1

Roughly the same as defaulting

k8s.io/kube-openapi/cmd/openapi-gen \
  -h staging/src/k8s.io/code-generator/hack/boilerplate.go.txt \
  -O zz_generated.openapi \
  -p --output-package ./pkg/generated/openapi \
  -r --report-filename _output/KUBE_violations.report \
  -i ./pkg/apis/abac/v0

Roughly the same as defaulting, but 2 generators

k8s.io/code-generator/cmd/applyconfiguration-gen \
  --go-header-file staging/src/k8s.io/code-generator/hack/boilerplate.go.txt \
  --output-base /home/thockin/src/go/src/k8s.io/kubernetes/staging/src \
  --output-package k8s.io/client-go/applyconfigurations \
  --input-dirs k8s.io/api/admission/v1

# TODO: "pkg/client/applyconfigurations" is hardcoded in NewDefaults
# TODO: "k8s.io/kubernetes/pkg/apis" is hardcoded inputbase arg and never used

